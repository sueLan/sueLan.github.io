---
title: Beyond "po"
date: 2020-06-07 17:34:07
categories: 
  - iOS
tags:
  - Debug
  - LLDB

---

> https://developer.apple.com/videos/play/wwdc2019/429 

## po command

We usually use `po` to print object description, which does the same job as `expression --object-description`. 

### Alias the command  

We can also use `command alias` to custom it. like 

`command alias my_po expression --object-description` ![img](15902187135968.jpg)

### Custom the output  

We can add `debugDescription` to custom the output when using `po`

![image-20200607171902758](image-20200607171902758.png)

### Others jobs po can do 

![image-20200607172607792](image-20200607172607792.png)


### What LLDB does behind the `Po` command

![img](15902307367967.jpg?lastModify=1591521218)

## p command

```
p is a alias of `expression
```

![-w398](15902310620901.jpg?lastModify=1591521218)

The result of LLDB is given a increasing name, such as `$R1` and `$R2` 

![-w509](15902311269458.jpg?lastModify=1591521218)

## Dynamic type resolution

![img](15902347284185.jpg?lastModify=1591521218)

> In Swift, the static representation of a type in the source code and the dynamic type at the runtime, aren't necessarily the same. For example, a variable might be declared using a protocol of this type. In this example, the static type of `cruise` is `Activity`. But at runtime, the variable will have an instance of type `Trip` which is the dynamic time. If we print the value of `cruise`, we get back an object of type `Trip` because LLDB retell results metadata to display the most accurate type for a given variable at a given program point. This is what we call `dynamic type resolution`.

With the p-command, dynamic type resolution is `only` performed on the result of the `expression`.

This happens because if you remember, LLDB compiles code where running p and the only type it sees is the one in your source code, the static one. It's the same thing as typing the expression `cruise.name` in your source code. The static compiler will reject it with an error.  ![-w1104](15902348043124.jpg?lastModify=1591521218)

If you want to evaluate the expression without errors, you need to first cast the object explicitly to its dynamic type and then access the field on the result. This is true both for the debugger and your source code.

![img](15902348340793.jpg?lastModify=1591521218)

### “p” Under the Hood

![img](15902348740856.jpg?lastModify=1591521218)

### Formatter 

After it performed `dynamic type resolution` on the result, LLDB passes the resulting object to the `formatter subsystem` which is the part of LLDB responsible for printing a human readable description of objects.

![-w850](15902349355474.jpg?lastModify=1591521218)

## v Command

- The output of `v` is exactly the same as `p` as it also relies on the formatter we just described.
- `v` is just an alias we introduced in Xcode 10.2 for the `frame` variable command
- The v-command doesn't compile and execute code at all which makes it very fast.

![img](15902351819724.jpg?lastModify=1591521218)

### v under the hood 

![img](15902354049114.jpg?lastModify=1591521218)

### frame command

![-w799](15902352051371.jpg?lastModify=1591521218)

## po vs p vs v

![-w1306](15902354519154.jpg?lastModify=1591521218)

