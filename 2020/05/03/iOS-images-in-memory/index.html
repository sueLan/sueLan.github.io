<!DOCTYPE html>
<html lang="zh-CN">

  
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  <meta name="author" content="RY">
  
  
  
  <title>iOS images in memory | RY &#39;s Blog</title>

  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
    <meta name="keywords" content="iOS,Image,Memory,Debug,">
  

  <script>
    console.log('\n%c Hexo-theme-bmw v4.0 ' + '%c üéâ https://github.com/dongyuanxin/theme-bmw üéâ\n' + '\n%c View demo online ' + '%c üîç https://godbmw.com/ üîç  \n' , 'color: #fadfa3; background: #030307; padding:3px 0;', '', 'color: #fadfa3; background: #030307; padding:3px 0;', '');
  </script>

  

  

  
    <link rel="icon" href="/img/favicon.ico">
    <link rel="apple-touch-icon" href="/img/favicon.ico">
  

  <link href="https://cdn.bootcss.com/fancybox/3.5.2/jquery.fancybox.min.css" rel="stylesheet">
  <link rel="stylesheet" href="/css/base.css">
<link rel="stylesheet" href="/icon/iconfont.css">
<link rel="stylesheet" href="/css/github-markdown.css">
<link rel="stylesheet" href="/css/highlight.css">

  <script src="/js/util.js"></script>
<script src="/js/valine.min.js"></script>

  

  
    <link href="https://cdn.bootcss.com/aplayer/1.10.1/APlayer.min.css" rel="stylesheet">
    <script src="https://cdn.bootcss.com/aplayer/1.10.1/APlayer.min.js" async></script>
  

  
    <link href="https://cdn.bootcss.com/social-share.js/1.0.16/css/share.min.css" rel="stylesheet">
  
  
  <script src="//cdn.bootcss.com/jquery/3.3.1/jquery.min.js" async></script>
  
  
    <script src="//cdn.jsdelivr.net/npm/leancloud-storage@3.11.0/dist/av-min.js"></script>
  

</head>

  <body>

    

    <div id="app">

      <div class="header-wrap">
  <header>
    <div class="site-brand">
      <div class="site-title">
        <a href="/">RY</a>
      </div>
    </div>
    <nav class="site-navigation">
      <ul class="nav-menu">
      
        <li class="nav-item" data-path="/">
          
            <a 
              href="/"
              target="_self"
            >
              Home
            </a>
          
        </li>
      
        <li class="nav-item" data-path="/archives/">
          
            <a 
              href="/archives/"
              target="_self"
            >
              Archives
            </a>
          
        </li>
      
        <li class="nav-item" data-path="/categories/">
          
            <a 
              href="/categories/"
              target="_self"
            >
              Categories
            </a>
          
        </li>
      
        <li class="nav-item" data-path="/tags/">
          
            <a 
              href="/tags/"
              target="_self"
            >
              Tags
            </a>
          
        </li>
      
        <li class="nav-item" data-path="/about/">
          
            <a 
              href="/about/"
              target="_self"
            >
              About
            </a>
          
        </li>
      
        <li class="nav-item" data-path="">
          
            <a href="javascript:void(0);" v-else>Me</a>
            <ul class="nav-menu--dropdown">
              
                <li>
                  <a 
                    href="https://github.com/sueLan" 
                    target="_blank"
                  >
                    Github
                  </a>
                </li>
              
                <li>
                  <a 
                    href="https://stackoverflow.com/users/4026902/ry-zheng" 
                    target="_blank"
                  >
                    StackOverflow
                  </a>
                </li>
              
                <li>
                  <a 
                    href="https://www.jianshu.com/u/23bd8d4cc8bf" 
                    target="_blank"
                  >
                    Jian Shu
                  </a>
                </li>
              
            </ul>
          
        </li>
      
      </ul>
    </nav>
    <i class="iconfont icon-menu"></i>
  </header>
</div>

<script>
  let links = document.querySelectorAll('.nav-item');
  for(let link of links){
    let childrenLink = link.querySelector('ul');
    link.addEventListener('mouseenter', () => {
      if(childrenLink) {
        childrenLink.className = "nav-menu--dropdown active";
      }
    })
    link.addEventListener('mouseleave', () => {
      if(childrenLink) {
        childrenLink.className = "nav-menu--dropdown";
      }
    })
  }
  let rootRealPath = getRealPath(window.location.pathname, true);
  for(let link of links) {
    let linkPath = link.getAttribute("data-path");
    if(linkPath && getRealPath(linkPath, true) === rootRealPath) {
      link.className = "nav-item hover";
    }
  }

  let iconMenu = document.querySelector("i.iconfont.icon-menu"),
    iconMenuClicked = false;
  let navDOM = document.querySelector("nav.site-navigation");
  iconMenu.addEventListener("click", () => {
    iconMenuClicked 
      ? navDOM.className = "site-navigation active"
      : navDOM.className = "site-navigation";
    iconMenuClicked = !iconMenuClicked;
  })
</script>

      








<div class="container post-index">

  

<div class="post">
  <h1 class="article-title">
    <span>iOS images in memory</span>
  </h1>
  <div class="article-top-meta">
    <span>
      post ime : 
      2020-05-03
    </span>
    
      <span>
        category : 
          <a href="/categories/iOS/">
            iOS
          </a>
      </span>
    
    
      <span>
        read : <span class="article-timer" data-identity="iOS-images-in-memory"></span>
      </span>
    
  </div>

  

  <div class="article-content">
    <div class="markdown-body">
      <blockquote>
<p>Notes for <a href="https://developer.apple.com/videos/play/wwdc2018/219" target="_blank" rel="noopener">wwdc2018/219</a> and <a href="https://developer.apple.com/videos/play/wwdc2018/416/" target="_blank" rel="noopener">wwdc2018/416</a></p>
</blockquote>
<h2 id="Why-memory-and-CPU-matter"><a href="#Why-memory-and-CPU-matter" class="headerlink" title="Why memory and CPU matter?"></a>Why memory and CPU matter?</h2><p><img src="media/15884695669510/15888626848016.jpg" alt></p>
<ul>
<li>It is obvious that too much usage of <code>CPU</code> has negative impact on <code>battery life</code> and <code>responsiveness</code>.  </li>
<li>But, if you application consumes too much memory, that causes more <code>CPU utilization</code>, which have negative effects on <code>battery life</code> and <code>performance</code>.</li>
</ul>
<h2 id="Basic-Concepts"><a href="#Basic-Concepts" class="headerlink" title="Basic Concepts"></a>Basic Concepts</h2><h3 id="Buffers"><a href="#Buffers" class="headerlink" title="Buffers"></a>Buffers</h3><blockquote>
<p>Buffer is contiguous region of memory.<br>It is often viewed as sequence of elements of the same sizes, usually of the same internal construction. </p>
</blockquote>
<p><img src="media/15884695669510/15888596565806.jpg" alt="-w354"></p>
<h4 id="Image-Buffers"><a href="#Image-Buffers" class="headerlink" title="Image Buffers"></a>Image Buffers</h4><blockquote>
<p>One kind of the important buffers is the <code>Image Buffer</code>, which holds the <code>in-memory representation of some image</code>. </p>
</blockquote>
<p>Each element in image buffers describes the color and the transparency of single pixel in our image. Constantly, the buffer size is proportional to image size. For example, in the image with sRBG format, each 32 bits describes the color and transparency of a single pixel. <code>The buffer size =  4 byte  x image_width x image_height</code></p>
<p><img src="media/15884695669510/15888600604360.jpg" alt="-w452"></p>
<h4 id="Frame-buffer"><a href="#Frame-buffer" class="headerlink" title="Frame buffer"></a>Frame buffer</h4><blockquote>
<p>The frame buffer is what holds the actual rendered output of your application.  </p>
</blockquote>
<p>As your application updates its view hierarchy UIKit will render the application‚Äôs <code>window</code> and all of its <code>subviews</code> into the <code>frame buffer</code>. And that frame buffer provides per pixel color information that the <code>display hardware</code> will read in order to illuminate the pixels on the display.</p>
<p><a href="https://developer.apple.com/library/archive/documentation/WindowsViews/Conceptual/ViewPG_iPhoneOS/WindowsandViews/WindowsandViews.html#//apple_ref/doc/uid/TP40009503-CH2-SW10" target="_blank" rel="noopener">Related resource: The View Drawing Cycle</a></p>
<p>The pipeline is like this: </p>
<p><img src="image_graphic.gif" alt></p>
<h4 id="Data-Buffer"><a href="#Data-Buffer" class="headerlink" title="Data Buffer"></a>Data Buffer</h4><blockquote>
<p>a data buffer is just a buffer that contains a sequence of bytes. </p>
</blockquote>
<p>If we‚Äôve downloaded images from the network or we‚Äôve <code>loaded</code> them from disk. A data buffer that contains an image file, typically, begins with some metadata describing the size of the image that‚Äôs stored in that data buffer.</p>
<p><img src="media/15884695669510/15888655020412.jpg" alt="-w397"></p>
<ul>
<li>Store contents of an <code>image file</code> in memory. The <code>size</code> is the same as that in the image file in the disk. </li>
<li>Metadata describing dimensions of image</li>
<li>Image itself <code>encoded</code> as JPEG, PNG, or other (usually compressed) form</li>
<li>Bytes <code>do not</code>directly describe pixels</li>
</ul>
<h3 id="The-Pipeline-in-Action"><a href="#The-Pipeline-in-Action" class="headerlink" title="The Pipeline in Action"></a>The Pipeline in Action</h3><p><img src="media/15884695669510/15890026431784.jpg" alt="-w834"></p>
<h2 id="Consequences-of-Excessive-Memory-Usage"><a href="#Consequences-of-Excessive-Memory-Usage" class="headerlink" title="Consequences of Excessive Memory Usage"></a>Consequences of Excessive Memory Usage</h2><ul>
<li>Increased fragmentation. <ul>
<li><code>fragment</code> : The large allocation that is in your application‚Äôs address space could force other related content apart from content that it wants to reference.</li>
</ul>
</li>
<li>Poor locality of reference</li>
<li><p>System starts <code>compressing</code> memory Process termination</p>
<ul>
<li>Eventually, if your application starts accumulating a lot of memory usage the operating system will step in and start transparently <code>compressing</code> the content of physical memory. Now, the CPU needs to be involved in this operation so in addition to any CPU usage in your own application. You could be <code>increasing global CPU usage</code> that you have no control over. Eventually, your application could start consuming so much physical memory that the OS needs to start <code>terminating processes</code>. And it‚Äôll start with background processes of low priority.</li>
</ul>
</li>
<li><p>You app may be terminated by the system</p>
</li>
<li>Cause <code>CPU peak</code>, and then has negative impact on battery life and responsiveness.</li>
</ul>
<h2 id="Decoding"><a href="#Decoding" class="headerlink" title="Decoding"></a>Decoding</h2><blockquote>
<p>Decoding is an operation that will convert the JPEG or PNG or other encoded image data into per pixel image information. </p>
</blockquote>
<ul>
<li><p>CPU-intensive process</p>
</li>
<li><p>The memory used for the image buffer is proportional to original image size, not view size. </p>
</li>
<li>There are persistent large memory allocation in decoding.</li>
<li>The image buffer is retained for repeat rendering by UIImage. </li>
</ul>
<p>After decoding, UIImage will hang onto that image buffer, so that it only does that work once. Consequently, your application, for every image that gets decoded, could have a persistent and large memory allocation hanging out.</p>
<h2 id="The-memory-use-of-an-image-using-sRGB-space"><a href="#The-memory-use-of-an-image-using-sRGB-space" class="headerlink" title="The memory use of an image using sRGB space"></a>The memory use of an image using sRGB space</h2><blockquote>
<p>Memory use is related to the dimensions of the images, not the file size.</p>
</blockquote>
<p>Take the following image as an instance, its file size is 590KB, with dimension 2048 x 1536 pixel.<br><img src="28bfb5ac-c3fa-4575-a1b1-72fcbacc9069/83dca9cf.png" alt="83dca9cf.png"></p>
<h3 id="4-byetes-for-each-pixel-in-RGBA"><a href="#4-byetes-for-each-pixel-in-RGBA" class="headerlink" title="4 byetes for each pixel in RGBA"></a>4 byetes for each pixel in RGBA</h3><p>By this <a href="https://www.objc.io/issues/3-views/moving-pixels-onto-the-screen/" target="_blank" rel="noopener">article</a>, each pixel in sRGB image needs 32bit, 4 bytes, in memory when it‚Äôs decoded. Because in sRGB, there are Red, Green, Blue 3 channels and Alpha. The range of each channel value is from 0 to 255, which needs 8 bits to represent the value. </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> A   R   G   B   A   R   G   B   A   R   G   B  </span><br><span class="line">| pixel 0       | pixel 1       | pixel 2   </span><br><span class="line"> 0  233  2  100  4  155 255  7   8   9   10  11</span><br></pre></td></tr></table></figure>
<h3 id="More-memory-usage-when-decoding-a-image"><a href="#More-memory-usage-when-decoding-a-image" class="headerlink" title="More memory usage when decoding a image"></a>More memory usage when decoding a image</h3><p>A image have load -&gt; decode -&gt; render these 3 phases.  </p>
<p><img src="28bfb5ac-c3fa-4575-a1b1-72fcbacc9069/ed4e1c96.png" alt="64aaa3cd.png"></p>
<p>We only need 590KB to load a image, while we need<br><code>2048 pixels x 1536 pixels x 4 bytes per pixel</code> = 10MB when decoding </p>
<h2 id="Image-Rendering-Pipeline"><a href="#Image-Rendering-Pipeline" class="headerlink" title="Image Rendering Pipeline"></a>Image Rendering Pipeline</h2><ul>
<li><code>UIImage</code> is responsible for loading image content. Usually, it is bigger than the ImageView that is going to display it. </li>
<li><code>UIImageView</code> is responsible for displaying the image. The image which it is going to display will be shrink down to fit its size.<br><img src="media/15884695669510/15889026761062.jpg" alt></li>
</ul>
<h2 id="Downsampling"><a href="#Downsampling" class="headerlink" title="Downsampling"></a>Downsampling</h2><p>So, we can use technique, called Downsampling, to <code>downsample</code> the images to <code>the size that they&#39;re going to be displayed</code>. Rather than having these large allocations hanging around, we‚Äôre reducing our memory usage.</p>
<p><img src="media/15884695669510/15889088392417.jpg" alt="-w1333"></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Downsampling large images for display at smaller size</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">downsample</span><span class="params">(imageAt imageURL: URL, to pointSize: CGSize, scale: CGFloat)</span></span> -&gt; <span class="type">UIImage</span> &#123;</span><br><span class="line">    <span class="comment">// ShouldCache flag tells Core Graphics framework that we're just creating an object to</span></span><br><span class="line">    <span class="comment">// represent the infomation stored in the file at this URL</span></span><br><span class="line">    <span class="keyword">let</span> imageSourceOptions = [kCGImageSourceShouldCache: <span class="literal">false</span>] <span class="keyword">as</span> <span class="type">CFDictionary</span></span><br><span class="line">    <span class="keyword">let</span> imageSource = <span class="type">CGImageSourceCreateWithURL</span>(imageURL <span class="keyword">as</span> <span class="type">CFURL</span>, imageSourceOptions)!</span><br><span class="line">    <span class="keyword">let</span> maxDimensionInPixels = <span class="built_in">max</span>(pointSize.width, pointSize.height) * scale</span><br><span class="line">    <span class="keyword">let</span> downsampleOptions =</span><br><span class="line">        <span class="comment">// Ask the Core Graphics to create the decoded image buffer for me when calling it to create the thumbnail</span></span><br><span class="line">        [kCGImageSourceCreateThumbnailFromImageAlways: <span class="literal">true</span>,</span><br><span class="line">        kCGImageSourceShouldCacheImmediately: <span class="literal">true</span>,</span><br><span class="line">        <span class="comment">// Should include kCGImageSourceCreateThumbnailWithTransform: true in the options dictionary. Otherwise, the image result will appear rotated when an image is taken from camera in the portrait orientation.</span></span><br><span class="line">        kCGImageSourceCreateThumbnailWithTransform: <span class="literal">true</span>,</span><br><span class="line">        kCGImageSourceThumbnailMaxPixelSize: maxDimensionInPixels] <span class="keyword">as</span> <span class="type">CFDictionary</span></span><br><span class="line">    <span class="keyword">let</span> downsampledImage =</span><br><span class="line">        <span class="type">CGImageSourceCreateThumbnailAtIndex</span>(imageSource, <span class="number">0</span>, downsampleOptions)!</span><br><span class="line">    <span class="keyword">return</span> <span class="type">UIImage</span>(cgImage: downsampledImage)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Decoding-in-ScrollViews"><a href="#Decoding-in-ScrollViews" class="headerlink" title="Decoding in ScrollViews"></a>Decoding in ScrollViews</h2><h3 id="The-cause-of-the-ScrollView-hitch"><a href="#The-cause-of-the-ScrollView-hitch" class="headerlink" title="The cause of the ScrollView hitch"></a>The cause of the ScrollView hitch</h3><p><img src="media/15884695669510/15889147842616.jpg" alt="-w1178"></p>
<blockquote>
<p>When beginning scrolling, we‚Äôre about to display another row of images. And we‚Äôre about to ask Core Graphics to <code>decode</code> those images before we hand the cells back to UICollectionView.<br>And that could take <code>a lot of CPU time</code>. So much so, that we <code>don&#39;t</code> get around to <code>re-rendering the frame buffer</code>. But the <code>display hardware</code> is operating on a <code>fixed interval</code>. So, from the user‚Äôs perspective the application has just <code>stuttered</code>. Now, we‚Äôre done decoding these images, we‚Äôre able to provide those cells back to UICollectionView. And animation continues on, as before. Just saw a <code>visual hitch</code>, </p>
</blockquote>
<h2 id="Two-techniques-to-smooth-out-CPU-usage"><a href="#Two-techniques-to-smooth-out-CPU-usage" class="headerlink" title="Two techniques to smooth out CPU usage"></a>Two techniques to smooth out CPU usage</h2><ol>
<li>prefetching </li>
<li>performing work in the background</li>
</ol>
<h3 id="Thread-Explosion"><a href="#Thread-Explosion" class="headerlink" title="Thread Explosion"></a>Thread Explosion</h3><p>It is caused by </p>
<ul>
<li>More images to decode than available CPUs </li>
<li>GCD continues creating threads as new work is enqueued</li>
<li>Each thread gets less time to actually decode images</li>
</ul>
<blockquote>
<p>Now, to avoid deadlock when we dispatch asynchronously to a global queue, GCD is going to create new threads to capture the work we‚Äôre asking it to do. And then, the CPUs are going to spend a lot of time moving between those threads to try and make incremental progress on all of the work we asked the operating system to do for us. And switching between those threads, actually, has a pretty significant overhead.</p>
</blockquote>
<p>we‚Äôre going to serialize some work.</p>
<p>So, rather than simply dispatching work to one of the global asynchronous queues, we‚Äôre going to create a serial queue. And inside of our implementation of the prefetch method we‚Äôre going to asynchronously dispatch to that queue.</p>
<p><img src="media/15884695669510/15889150745604.jpg" alt="-w1516"></p>
<h2 id="Image-Sources"><a href="#Image-Sources" class="headerlink" title="Image Sources"></a>Image Sources</h2><p>Images may come from </p>
<ul>
<li>Image assets in asset catalog</li>
<li>Files in application/framework bundle</li>
<li>Files in Documents and Caches directories </li>
<li>Data downloaded from network</li>
</ul>
<p>This session suggests us to use image assets for the following reasons: </p>
<ul>
<li><p>Optimized name- and trait-based lookup</p>
<ul>
<li>It‚Äôs <code>faster</code> to <code>look up</code> an image asset in the asset catalog, than it is to search for files on disk that have a certain naming scheme. </li>
</ul>
</li>
<li><p>Smarter buffer caching</p>
<ul>
<li>The asset catalog runtime has, also, got some really good smarts in it for managing <code>buffer sizes</code>.</li>
</ul>
</li>
<li><p>Per-device thinning</p>
<ul>
<li>your application only downloads image resources that are relevant to the device that it‚Äôs going to run on and vector artwork. The </li>
</ul>
</li>
<li><p>Vector artwork</p>
</li>
</ul>
<h2 id="Vector-artwork"><a href="#Vector-artwork" class="headerlink" title="Vector artwork"></a>Vector artwork</h2><ul>
<li>Since iOS 11, image assets support‚Ä® ‚ÄúPreserve Vector Data‚Äù</li>
<li>Avoids blurriness and aliasing when drawn larger or smaller than natural size</li>
</ul>
<h2 id="Image-Rendering-Format"><a href="#Image-Rendering-Format" class="headerlink" title="Image Rendering Format"></a>Image Rendering Format</h2><h3 id="SRGB"><a href="#SRGB" class="headerlink" title="SRGB"></a>SRGB</h3><ul>
<li>4 bytes per pixel </li>
<li>full color images </li>
<li>most common used<br><img src="28bfb5ac-c3fa-4575-a1b1-72fcbacc9069/a1bf604b.png" alt="a1bf604b.png"></li>
</ul>
<h3 id="Wide-format"><a href="#Wide-format" class="headerlink" title="Wide format"></a>Wide format</h3><ul>
<li>8 bytes per pixel </li>
<li>super accurate colors. Because they use 8bytes, 16 bits, for each channel. In the meantime, double the image size.  </li>
<li>Only useful with wide color display. We don‚Äôt want to use it when we don‚Äôt need to. </li>
<li>Wide color capture cameras since iPhone 7</li>
</ul>
<p><img src="28bfb5ac-c3fa-4575-a1b1-72fcbacc9069/75a1a01e.png" alt="75a1a01e.png"></p>
<h3 id="Luminance-and-alpha-8-format"><a href="#Luminance-and-alpha-8-format" class="headerlink" title="Luminance and alpha 8 format"></a>Luminance and alpha 8 format</h3><p>This image only holds grayscale value. And the image size is smaller. </p>
<ul>
<li>2 bytes per pixel </li>
<li>Single-color iamges and alpha</li>
<li><p>Most used in Metal shaders, not very common.<br><img src="28bfb5ac-c3fa-4575-a1b1-72fcbacc9069/6383b177.png" alt="6383b177.png"></p>
<h3 id="Alpha-8-Format"><a href="#Alpha-8-Format" class="headerlink" title="Alpha 8 Format"></a>Alpha 8 Format</h3></li>
<li><p>1 byte per pixel </p>
</li>
<li>Userful for monochrome images because it uses less memory. <ul>
<li>masks </li>
<li>Emoji-free text </li>
</ul>
</li>
<li>75% smaller than SRGB</li>
</ul>
<p><img src="28bfb5ac-c3fa-4575-a1b1-72fcbacc9069/753920b5.png" alt="753920b5.png"><br>We can also change <code>image.tintColor</code> in this image without changing its format.  </p>
<h2 id="How-do-I-pick-the-right-format"><a href="#How-do-I-pick-the-right-format" class="headerlink" title="How do I pick the right format?"></a>How do I pick the right format?</h2><p><code>UIGraphicsBeginImageContextWithOptions</code> always uses SRGB rendering-format, which use 4 bytes per pixel. </p>
<p>while <code>UIGraphicsImageRenderer</code>, which introduced in iOS 10 will automatically pick the best graphic format in iOS12. It means, you will save 75% of memory by replacing <code>UIGraphicsBeginImageContextWithOptions</code> with  <code>UIGraphicsImageRenderer</code></p>
<p><strong>Do</strong> ‚úÖ</p>
<p><img src="28bfb5ac-c3fa-4575-a1b1-72fcbacc9069/2f0229d3.png" alt="2f0229d3.png"></p>
<h2 id="Use-ImageIO-to-downsample-images"><a href="#Use-ImageIO-to-downsample-images" class="headerlink" title="Use ImageIO to downsample images"></a>Use ImageIO to downsample images</h2><p><code>UIImage</code> is expensive for sizing and to resizing</p>
<ul>
<li>Will decompress original image into memory </li>
<li>Internal coordinate space transforms are expensive</li>
</ul>
<p><strong>Don‚Äôt</strong> ‚ùå</p>
<p><img src="28bfb5ac-c3fa-4575-a1b1-72fcbacc9069/c25d45de.png" alt="c25d45de.png"></p>
<p>Use ImageIO</p>
<ul>
<li><p>ImageIO can read image sizes and metadata information without dirtying memory.</p>
</li>
<li><p>ImageIO can resize images at cost of resized image only.</p>
</li>
</ul>
<p><strong>Do</strong> ‚úÖ<br><img src="28bfb5ac-c3fa-4575-a1b1-72fcbacc9069/922ac245.png" alt="922ac245.png"></p>
<p>The bad is that you have to specify some options. </p>
<h2 id="Resize-image-effectively"><a href="#Resize-image-effectively" class="headerlink" title="Resize image effectively"></a>Resize image effectively</h2><p>This is a function of resizing image without reading it into the memory, using ImageIO.  </p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">resize</span><span class="params">(url: NSURL, maxPixelSize: Int)</span></span> -&gt; <span class="type">CGImage?</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> imgSource = <span class="type">CGImageSourceCreateWithURL</span>(url, <span class="literal">nil</span>)</span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> imageSource = imgSource <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> scaledImage: <span class="type">CGImage?</span></span><br><span class="line">    <span class="keyword">let</span> options: [<span class="type">NSString</span>: <span class="type">Any</span>] = [</span><br><span class="line">            <span class="comment">// The maximum width and height in pixels of a thumbnail.</span></span><br><span class="line">            kCGImageSourceThumbnailMaxPixelSize: maxPixelSize,</span><br><span class="line">            kCGImageSourceCreateThumbnailFromImageAlways: <span class="literal">true</span>,</span><br><span class="line">            <span class="comment">// Should include kCGImageSourceCreateThumbnailWithTransform: true in the options dictionary. Otherwise, the image result will appear rotated when an image is taken from camera in the portrait orientation.</span></span><br><span class="line">            kCGImageSourceCreateThumbnailWithTransform: <span class="literal">true</span></span><br><span class="line">    ]</span><br><span class="line">    scaledImage = <span class="type">CGImageSourceCreateThumbnailAtIndex</span>(imageSource, <span class="number">0</span>, options <span class="keyword">as</span> <span class="type">CFDictionary</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> scaledImage</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> filePath = <span class="type">Bundle</span>.main.path(forResource:<span class="string">"large_leaves_70mp"</span>, ofType: <span class="string">"jpg"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> url = <span class="type">NSURL</span>(fileURLWithPath: filePath ?? <span class="string">""</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> image = resize(url: url, maxPixelSize: <span class="number">600</span>)</span><br></pre></td></tr></table></figure>
<h2 id="Optimizing-when-in-the-background"><a href="#Optimizing-when-in-the-background" class="headerlink" title="Optimizing when in the background"></a>Optimizing when in the background</h2><h3 id="foreground-background"><a href="#foreground-background" class="headerlink" title="foreground/background"></a>foreground/background</h3><p>The strategy is simple, when <code>UIApplicationDidEnterBackground</code>, we unload images; and when <code>UIApplicationWillEnterForeground</code>, load images. </p>
<h3 id="on-screen-off-screen"><a href="#on-screen-off-screen" class="headerlink" title="on-screen/off-screen"></a>on-screen/off-screen</h3><p>unload large resource when off-screen, <code>viewDidDisappear</code>; and load large resource when on-screen, <code>viewWillAppear</code>. </p>
<h2 id="Debug"><a href="#Debug" class="headerlink" title="Debug"></a>Debug</h2><p>Use memory graphs to further understand and reduce memory footprint</p>
<h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ul>
<li><a href="https://developer.apple.com/videos/play/wwdc2018/416/" target="_blank" rel="noopener">An great example of how to use command line tools to find root cause of an image memory issue.</a>  </li>
</ul>
<h2 id="Related"><a href="#Related" class="headerlink" title="Related"></a>Related</h2><ul>
<li><a href="https://suelan.github.io/2020/05/03/An-glimpse-of-iOS-Memory-Deep-Dive/">An-glimpse-of-iOS-Memory-Deep-Dive</a></li>
<li><a href="https://suelan.github.io/2020/05/09/20190509-Work-with-Wider-Color">Work with Wider Color </a></li>
</ul>

    </div>
  </div>
  
    <div class="copy-right">
      <div class="markdown-body">
        <blockquote>
        
        
          Author : RY Zheng <br/>
        
        Link : <a href="">https://suelan.github.io/2020/05/03/iOS-images-in-memory/</a><br>
        License : MIT
        </blockquote>
      </div>
    </div>
  
  
  
    <div class="social-share"
  style="margin-top: -2rem"
  data-wechat-qrcode-title="<p>ÂæÆ‰ø°Êâ´‰∏ÄÊâ´</p>"
  data-wechat-qrcode-helper="<p>ÂæÆ‰ø°Âè≥‰∏äËßí, Êâ´‰∏ÄÊâ´ÂàÜ‰∫´</p>"
   data-sites="qzone, qq, weibo, wechat, douban, google, facebook, twitter" 
  
>
  <span style="color: #6b7487; font-size: 1.4rem;">Share To: </span>
</div>
<script src="https://cdn.bootcss.com/social-share.js/1.0.16/js/social-share.min.js" async>
  

  
    <div id="reward">
  
    <p id="reward-meta">Buy me a cup of coffee</p>
  
  <button id="reward-btn">
    
    <span>ËµûËµè ‚òïÔ∏è</span>
  </button>
  <div id="reward-qrcode">
    
      <div class="reward-qrcode--container">
        <img class="qrcode-img" src="/img/donate.jpeg" alt="ÊÑüË∞¢ÈºìÂä±">
        <p class="qrcode-meta">ÊÑüË∞¢ÈºìÂä±</p>
      </div>
    
  </div>

</div>

<script>
  (() => {
    let button = document.querySelector('#reward-btn'),
      qrcode = document.querySelector('#reward-qrcode'),
      display = false;
    
    button.addEventListener('click', () => {
      qrcode.style.display = display ? 'none' : 'block'
      display = !display
    }, false)
  })()
</script>
  

  <div class="article-footer">
    <div class="article-meta pull-left">
      <span>
        
          <i class="iconfont icon-06tags"></i>Ê†áÁ≠æ: 
          
          <span class="span--tag">
            <a href="/tags/Image/">
              #Image
            </a>
          </span>
          
          <span class="span--tag">
            <a href="/tags/Memory/">
              #Memory
            </a>
          </span>
          
          <span class="span--tag">
            <a href="/tags/Debug/">
              #Debug
            </a>
          </span>
          
        
      </span>
    </div>
    <div class="article-meta pull-right">
    </div>
  </div>
</div>


  <aside id="sidebar">
    <p id="sidebar-header"></p>
    <ol id="sidebar-toc"></ol>
  </aside>
  <script async>setTimeout(generateToc, 10);</script>


  <nav class="post-navigation">
    
      <div class="nav-pre">
        <i class="iconfont icon-prev"></i>
        Previous Article:
        <a href="/2020/05/03/An-glimpse-of-iOS-Memory-Deep-Dive/" target="_self">A glimpse of iOS Memory Deep Dive</a>
      </div>
    
    
      <div class="nav-next">
        Nex Article:
        <a href="/2020/05/09/20190509-Work-with-Wider-Color/" target="_self">Work with Wider Color</a>
        <i class="iconfont icon-next"></i>
      </div>
    
  </nav>

  
    <a href="#comment" class="comment-anchor"></a>
<div class="comment-title"><i class="iconfont icon-footprint"></i> Comments Here <i class="iconfont icon-footprint"></i></div>
<div id="vcomments"></div>

<script defer>
  if( true ) {
    let path = getRealPath()
    new Valine({
      el: "#vcomments",
      appId: "pyVXg5NFiE5JcCDYwumMNjlB-gzGzoHsz",
      appKey: "W9uovU160HsQkI3hQwlHgBqa",
      notify: false,
      verify: false,
      avatar: "robohash",
      placeholder: "Please fill in the correct email address for my response. ‚ô™(^‚àá^*)",
      path
    });
  }
</script>
   

  
    <script defer>
const valineAPI = (() => {
  try {
    AV.init("pyVXg5NFiE5JcCDYwumMNjlB-gzGzoHsz", "W9uovU160HsQkI3hQwlHgBqa");
  } catch(error) {}
  const isExist = (identity) => {
    identity = identity || getRealPath();
    let query = new AV.Query('Timer');
    return new Promise((resolve, reject) => {
      query.equalTo("identity", identity);
      query.find().then(results => {
        resolve(results.length > 0);
      }, error => reject(error));
    })
  }

  const _get = (identity) => {
    let query = null;
    if(identity && identity instanceof Array){
      let querys = [];
      for(let i = 0; i < identity.length; ++i) {
        querys[i] = new AV.Query('Timer');
        querys[i].equalTo('identity', identity[i]);
      }
      query = AV.Query.or.apply(null ,querys);
    } else {
      identity = identity || getRealPath();
      query = new AV.Query("Timer");
      query.equalTo("identity", identity);
    }

    return new Promise((resolve, reject) => {
      query.find()
      .then(results => resolve(results))
      .catch(error => reject(error))
    })
  }

  const create = (identity) => {
    identity = identity || getRealPath();
    return new Promise((resolve, reject) => {
      let Todo = AV.Object.extend('Timer');
      let todo = new Todo();
      todo.set("times", 1);
      todo.set("identity", identity);
      todo.save().then(res => resolve(true), error => reject(error));
    })
  }

  const update = (identity) => {
    identity = identity || getRealPath();
    return new Promise((resolve, reject) => {
      let query = new AV.Query('Timer');
      query.equalTo("identity", identity);
      query.find().then(todos => {
        todos.forEach(todo => {
          todo.set("times", todo.attributes.times + 1);
        });
        return AV.Object.saveAll(todos);
      }).then(todos => resolve(true), error => reject(error));
    })
  }

  return {
    isExist,
    _get,
    update,
    create
  }
})()

const calcAndWriteTimes = () => {
  let isPost = true;

  let timerAllDOM = document.querySelectorAll(".article-timer");

  if(isPost) {
    let identity = timerAllDOM[0].getAttribute("data-identity");
    valineAPI.isExist(identity)
    .then(exist => {
      if(exist) {
        return valineAPI.update(identity);
      }
      return new Promise(resolve => resolve(true));
    })
    .then( succuess => valineAPI._get(identity))
    .then( result => timerAllDOM[0].innerText = result[0].attributes.times)
    .catch(error => console.log(error.message))
    return ;
  }

  let timerDOMCache = {};

  for(let timerDOM of timerAllDOM) {
    let identity = timerDOM.getAttribute("data-identity");
    if(timerDOMCache.hasOwnProperty(identity)){
      timerDOMCache[identity].dom.push(timerDOM);
    }else{
      timerDOMCache[identity] = {
        dom: [timerDOM],
        times: undefined
      };
    }
  }

  let identities = Object.keys(timerDOMCache);
  valineAPI._get(identities).then(results => {
    for(let result of results) {
      let {identity, times} = result.attributes;
      timerDOMCache[identity].times = times;
      timerDOMCache[identity].dom.map(item => item.innerText = times);
    }
    for(let identity of identities) {
      if(timerDOMCache[identity].times){
        continue;
      }
      timerDOMCache[identity].dom.map(item => item.innerText = 1);
      valineAPI.create(identity);
    }
  }).catch(error => console.log(error.message))
}

if(true){
  calcAndWriteTimes();
}
</script>
   

</div>


      <footer>
  <p class="site-info">
    ÂçöÂÆ¢Â∑≤ËêåËêåÂìíËøêË°å<span id="time-to-now"></span><span class="my-face">(‚óè'‚ó°'‚óè)Ôæâ‚ô•</span>
    <br>
    Theme - <a href="https://github.com/dongyuanxin/theme-bmw">BMW</a> | Made With üíó | Powered by <a href="https://godbmw.com/">GodBMW</a>
    <br>
    
      To see a World in a Grain of Sand;And a Heaven in a Wild Flower; Hold Infinity in the palm of your hand; And Eternity in an hour
    
  </p>
</footer>



<script>
const timeToNowDOM = document.querySelector("#time-to-now");
const startTimestamp = new Date(2019, 2, 10).getTime();

const updateTimeStr = () => {
  let offset = parseInt(
      (new Date().getTime() - startTimestamp) / 1000,
      10
    ),
    day = Math.floor(offset / 86400),
    hour = Math.floor((offset % 86400) / 3600),
    minute = Math.floor(((offset % 86400) % 3600) / 60),
    second = Math.floor(((offset % 86400) % 3600) % 60);
  timeToNowDOM.innerHTML =
    day + "Â§©" + hour + "Â∞èÊó∂" + minute + "ÂàÜÈíü" + second + "Áßí";
  setTimeout(updateTimeStr, 500);
}

setTimeout(updateTimeStr, 500);
</script>


      <div class="back-to-top hidden">
  <span>
    <i class="iconfont icon-60"></i><span></span>%
  </span>
</div>

<script>
const updateIconToTop = percent => {
  let dom = document.querySelector(".back-to-top span span");
  dom.innerText = percent;
  if(percent < 1) {
    document.querySelector(".back-to-top").className = "back-to-top hidden";
  } else {
    document.querySelector(".back-to-top").className = "back-to-top";
  }
}

const handleScoll = () => {
  let isRunning = false;
  return () => {
    if (isRunning) return;
    isRunning = true;
    window.requestAnimationFrame(timestamp => {
      let scrollTop =
          document.documentElement.scrollTop || document.body.scrollTop,
        scrollHeight =
          document.documentElement.scrollHeight ||
          document.body.scrollHeight,
        clientHeight =
          document.documentElement.clientHeight ||
          document.body.clientHeight;
      isRunning = false;
      if (scrollTop <= 1) {
        updateIconToTop(0);
        return;
      }
      if (scrollTop + clientHeight >= scrollHeight) {
        updateIconToTop(100);
      } else {
        updateIconToTop(parseInt(
          100 * scrollTop / (scrollHeight - clientHeight),
          10
        ));
      }
    });
  };
}

const backToTop = () => {
  let scrollTop =
      document.documentElement.scrollTop || document.body.scrollTop,
    delay = 10,
    time = 200;
  if (scrollTop <= 20) {
    document.documentElement.scrollTop = 0;
    document.body.scrollTop = 0;
    return;
  }
  let step = Math.ceil(scrollTop * delay / time);
  let timer = setInterval(() => {
    scrollTop =
      document.documentElement.scrollTop || document.body.scrollTop;
    if (scrollTop - step <= 0) {
      document.documentElement.scrollTop = 0;
      document.body.scrollTop = 0;
      clearInterval(timer);
    } else {
      document.documentElement.scrollTop = scrollTop - step;
      document.body.scrollTop = scrollTop - step;
    }
  }, delay);
}

document.addEventListener("scroll", handleScoll(), false);

document.querySelector(".back-to-top").addEventListener("click", backToTop, false);

</script>

    </div>

    
      <script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script>
<script>
  (() => {
    const mathjaxConfig = {
      showProcessingMessages: false, //ÂÖ≥Èó≠jsÂä†ËΩΩËøáÁ®ã‰ø°ÊÅØ
      messageStyle: "none", //‰∏çÊòæÁ§∫‰ø°ÊÅØ
      jax: ["input/TeX", "output/HTML-CSS"],
      tex2jax: {
        inlineMath: [["$", "$"], ["\\(", "\\)"]], //Ë°åÂÜÖÂÖ¨ÂºèÈÄâÊã©Á¨¶
        displayMath: [["$$", "$$"], ["\\[", "\\]"]], //ÊÆµÂÜÖÂÖ¨ÂºèÈÄâÊã©Á¨¶
        skipTags: ["script", "noscript", "style", "textarea", "pre", "code", "a"] //ÈÅøÂºÄÊüê‰∫õÊ†áÁ≠æ
      },
      "HTML-CSS": {
        availableFonts: ["STIX", "TeX"], //ÂèØÈÄâÂ≠ó‰Ωì
        showMathMenu: false //ÂÖ≥Èó≠Âè≥ÂáªËèúÂçïÊòæÁ§∫
      }
    }

    let mathjaxInterval = setInterval(() => {
      if(!window.MathJax){
        return;
      }
      window.MathJax.Hub.Config(mathjaxConfig)
      window.MathJax.Hub.Queue(["Typeset", MathJax.Hub, document.getElementById('app')])

      clearInterval(mathjaxInterval)
    }, 10)    
  })()
</script>
    

    <script src="https://cdn.bootcss.com/fancybox/3.5.2/jquery.fancybox.min.js" async></script>
<script async>
  let fancyTimer = setInterval(function(){
    if(!window.$){
      return;
    }
    $(document).ready(function() {
      $(".post img").each(function () {
        if($(this).parent().get(0).tagName.toLowerCase() === "a") {
          return;
        }
        // $(this).attr("data-fancybox", "gallery"); // if you add 'data-fancybox', img will display after showed
        var element = document.createElement("a");
        $(element).attr("data-fancybox", "gallery");
        $(element).attr("href", $(this).attr("src"));
        $(this).wrap(element);
      });
      
      clearInterval(fancyTimer);
    });
  }, 10);
</script>

    
  </body>

</html>
